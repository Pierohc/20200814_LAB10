<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Stf-Puzzle Simplified Version</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        #game-container {
            margin: 20px;
        }
        #puzzle {
            display: grid;
            gap: 2px;
        }
        .piece {
            border: 1px solid #000;
            background-size: cover;
            background-position: center;
            cursor: pointer;
        }
        #controls {
            margin-top: 20px;
        }
    </style>
</head>
<body>

<div id="game-container">


    <div style="display: flex;flex-direction: column; justify-content: center; align-items: center; row-gap: 20px">
        <p1 style="font-size: 20px">Stf-Puzzle Simplified Version</p1>
        <img src="/img/Crash_Tumbalobos.jpg" style="max-width: 90px">
        <div style="display: flex;flex-direction: row; column-gap: 20px">
            <input type="color" id="board-color" value="#ffffff">
            <input type="text" id="board-size" value="3x3" pattern="\d+x\d+" required>
        </div>
        <div>
            <button id="select-character" style=" cursor:pointer; background-color:#188755; border: none; color: white; padding: 10px; border-radius: 6px">Seleccionar personaje</button>
            <input type="file" id="file-input" accept="image/jpeg" style="display: none;">
        </div>

        <div>
            <button id="start-game" style="display: none; cursor:pointer; background-color:#188755; border: none; color: white; padding: 10px; border-radius: 6px">Iniciar el juego</button>
        </div>

    </div>

    <br>
    <br>

    <div style="display: flex;flex-direction: column; align-items: center">
        <canvas id="canvas" style="width: 800px;height: 900px"></canvas>
        <br />
        <input type="hidden" value="4" id="difficulty" />
    </div>






</div>

<script>
    let colorFondo = '#ffffff';
    let tamanioTablero = 3;
    let imageSrc = null;
    let puzzleArray = [];
    let emptyPosition = {};

    document.getElementById('board-color').addEventListener('input', function () {
        colorFondo = this.value;
    });

    document.getElementById('board-size').addEventListener('input', function () {
        const match = this.value.match(/^(\d+)x(\d+)$/);
        if (match) {
            tamanioTablero = parseInt(match[1]);
            document.getElementById('start-game').style.display = 'inline';
        } else {
            document.getElementById('start-game').style.display = 'none';
        }
    });

    document.getElementById('select-character').addEventListener('click', function () {
        document.getElementById('file-input').click();
    });

    document.getElementById('file-input').addEventListener('change', function (event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                imageSrc = e.target.result;
                document.getElementById('start-game').style.display = 'inline';
            };
            reader.readAsDataURL(file);
        }
    });

    document.getElementById('start-game').addEventListener('click', function () {
        if (imageSrc) {
            iniciarJuego();
        }
    });

    function iniciarJuego() {
        const puzzle = document.getElementById('puzzle');
        puzzle.style.display = 'grid';
        puzzle.style.gridTemplateColumns = `repeat(${tamanioTablero}, 100px)`;
        puzzle.style.backgroundColor = colorFondo;
        puzzle.innerHTML = '';

        puzzleArray = [];
        for (let i = 0; i < tamanioTablero * tamanioTablero - 1; i++) {
            puzzleArray.push(i);
        }
        puzzleArray.push(null);

        shuffleArray(puzzleArray);
        emptyPosition = { row: tamanioTablero - 1, col: tamanioTablero - 1 };

        for (let i = 0; i < puzzleArray.length; i++) {
            const piece = document.createElement('div');
            piece.className = 'piece';
            piece.style.width = '100px';
            piece.style.height = '150px';
            if (puzzleArray[i] !== null) {
                piece.style.backgroundImage = `url(${imageSrc})`;
                const row = Math.floor(i / tamanioTablero);
                const col = i % tamanioTablero;
                piece.style.backgroundPosition = `${-col * 100 / (tamanioTablero - 3)}% ${-row * 100 / (tamanioTablero - 1)}%`;
                piece.dataset.index = i;
                piece.addEventListener('click', movePiece);
            } else {
                piece.style.backgroundColor = colorFondo;
            }
            puzzle.appendChild(piece);
        }
    }

    function movePiece(event) {
        const index = parseInt(event.target.dataset.index);
        const row = Math.floor(index / tamanioTablero);
        const col = index % tamanioTablero;
        if (isMovable(row, col)) {
            const emptyIndex = emptyPosition.row * tamanioTablero + emptyPosition.col;
            [puzzleArray[index], puzzleArray[emptyIndex]] = [puzzleArray[emptyIndex], puzzleArray[index]];
            updatePuzzle();
            if (isSolved()) {
                document.getElementById('game-status').innerText = 'Â¡Juego terminado!';
            }
        }
    }

    function isMovable(row, col) {
        const rowDiff = Math.abs(row - emptyPosition.row);
        const colDiff = Math.abs(col - emptyPosition.col);
        return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
    }

    function updatePuzzle() {
        const puzzle = document.getElementById('puzzle');
        puzzle.innerHTML = '';
        for (let i = 0; i < puzzleArray.length; i++) {
            const piece = document.createElement('div');
            piece.className = 'piece';
            piece.style.width = `calc(100% / ${tamanioTablero} - 2px)`;
            piece.style.height = `calc(100% / ${tamanioTablero} - 2px)`;
            if (puzzleArray[i] !== null) {
                piece.style.backgroundImage = `url(${imageSrc})`;
                const row = Math.floor(i / tamanioTablero);
                const col = i % tamanioTablero;
                piece.style.backgroundPosition = `${-col * 100 / (tamanioTablero - 1)}% ${-row * 100 / (tamanioTablero - 1)}%`;
                piece.dataset.index = i;
                piece.addEventListener('click', movePiece);
            } else {
                piece.style.backgroundColor = colorFondo;
                emptyPosition = { row: Math.floor(i / tamanioTablero), col: i % tamanioTablero };
            }
            puzzle.appendChild(piece);
        }
    }

    function isSolved() {
        for (let i = 0; i < puzzleArray.length - 1; i++) {
            if (puzzleArray[i] !== i) {
                return false;
            }
        }
        return true;
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }
</script>

<script>
    const PUZZLE_HOVER_TINT = "#009900";
    const img = new Image();
    const canvas = document.querySelector("#canvas");
    const stage = canvas.getContext("2d");
    let difficulty = 4;
    let pieces;
    let puzzleWidth;
    let puzzleHeight;
    let pieceWidth;
    let pieceHeight;
    let currentPiece;
    let currentDropPiece;
    let mouse;
    img.addEventListener("load", onImage, false);
    document.getElementById('file-input').addEventListener('change', function (event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                img.src = e.target.result;
                document.getElementById('start-game').style.display = 'inline';
            };
            reader.readAsDataURL(file);
        }
    });

    function initPuzzle() {
        pieces = [];
        mouse = {x: 0, y: 0};
        currentPiece = null;
        currentDropPiece = null;
        stage.drawImage(
            img,
            0,
            0,
            puzzleWidth,
            puzzleHeight,
            0,
            0,
            puzzleWidth,
            puzzleHeight
        );
        createTitle("Click to Start Puzzle");
        buildPieces();


    }

    function setCanvas() {
        canvas.width = puzzleWidth;
        canvas.height = puzzleHeight;
        canvas.style.border = "1px solid black";
    }

    function onImage() {
        pieceWidth = Math.floor(img.width / difficulty);
        pieceHeight = Math.floor(img.height / difficulty);
        puzzleWidth = pieceWidth * difficulty;
        puzzleHeight = pieceHeight * difficulty;
        setCanvas();
        initPuzzle();
    }

    function createTitle(msg) {
        stage.fillStyle = "#000000";
        stage.globalAlpha = 0.4;
        stage.fillRect(100, puzzleHeight - 40, puzzleWidth - 200, 40);
        stage.fillStyle = "#FFFFFF";
        stage.globalAlpha = 1;
        stage.textAlign = "center";
        stage.textBaseline = "middle";
        stage.font = "20px Arial";
        stage.fillText(msg, puzzleWidth / 2, puzzleHeight - 20);
    }

    function buildPieces() {
        let i;
        let piece;
        let xPos = 0;
        let yPos = 0;
        for (i = 0; i < difficulty * difficulty -1; i++) {
            piece = {};
            piece.sx = xPos;
            piece.sy = yPos;
            pieces.push(piece);
            xPos += pieceWidth;
            if (xPos >= puzzleWidth) {
                xPos = 0;
                yPos += pieceHeight;
            }
        }

        document.getElementById('start-game').addEventListener('click', function () {
                shufflePuzzle();
        });
    }

    function shufflePuzzle() {
        pieces = shuffleArray(pieces);
        stage.clearRect(0, 0, puzzleWidth, puzzleHeight);
        let xPos = 0;
        let yPos = 0;
        for (const piece of pieces) {
            piece.xPos = xPos;
            piece.yPos = yPos;
            stage.drawImage(
                img,
                piece.sx,
                piece.sy,
                pieceWidth,
                pieceHeight,
                xPos,
                yPos,
                pieceWidth,
                pieceHeight
            );
            stage.strokeRect(xPos, yPos, pieceWidth, pieceHeight);
            xPos += pieceWidth;
            if (xPos >= puzzleWidth) {
                xPos = 0;
                yPos += pieceHeight;
            }
        }
        document.onpointerdown = onPuzzleClick;
    }

    function checkPieceClicked() {
        for (const piece of pieces) {
            if (
                mouse.x < piece.xPos ||
                mouse.x > piece.xPos + pieceWidth ||
                mouse.y < piece.yPos ||
                mouse.y > piece.yPos + pieceHeight
            ) {
                //PIECE NOT HIT
            } else {
                return piece;
            }
        }
        return null;
    }

    function updatePuzzle(e) {
        currentDropPiece = null;
        if (e.layerX || e.layerX == 0) {
            mouse.x = e.layerX - canvas.offsetLeft;
            mouse.y = e.layerY - canvas.offsetTop;
        } else if (e.offsetX || e.offsetX == 0) {
            mouse.x = e.offsetX - canvas.offsetLeft;
            mouse.y = e.offsetY - canvas.offsetTop;
        }
        stage.clearRect(0, 0, puzzleWidth, puzzleHeight);
        for (const piece of pieces) {
            if (piece == currentPiece) {
                continue;
            }
            stage.drawImage(
                img,
                piece.sx,
                piece.sy,
                pieceWidth,
                pieceHeight,
                piece.xPos,
                piece.yPos,
                pieceWidth,
                pieceHeight
            );
            stage.strokeRect(piece.xPos, piece.yPos, pieceWidth, pieceHeight);
            if (currentDropPiece == null) {
                if (
                    mouse.x < piece.xPos ||
                    mouse.x > piece.xPos + pieceWidth ||
                    mouse.y < piece.yPos ||
                    mouse.y > piece.yPos + pieceHeight
                ) {
                    //NOT OVER
                } else {
                    currentDropPiece = piece;
                    stage.save();
                    stage.globalAlpha = 0.4;
                    stage.fillStyle = PUZZLE_HOVER_TINT;
                    stage.fillRect(
                        currentDropPiece.xPos,
                        currentDropPiece.yPos,
                        pieceWidth,
                        pieceHeight
                    );
                    stage.restore();
                }
            }
        }
        stage.save();
        stage.globalAlpha = 0.6;
        stage.drawImage(
            img,
            currentPiece.sx,
            currentPiece.sy,
            pieceWidth,
            pieceHeight,
            mouse.x - pieceWidth / 2,
            mouse.y - pieceHeight / 2,
            pieceWidth,
            pieceHeight
        );
        stage.restore();
        stage.strokeRect(
            mouse.x - pieceWidth / 2,
            mouse.y - pieceHeight / 2,
            pieceWidth,
            pieceHeight
        );
    }

    function onPuzzleClick(e) {
        if (e.layerX || e.layerX === 0) {
            mouse.x = e.layerX - canvas.offsetLeft;
            mouse.y = e.layerY - canvas.offsetTop;
        } else if (e.offsetX || e.offsetX === 0) {
            mouse.x = e.offsetX - canvas.offsetLeft;
            mouse.y = e.offsetY - canvas.offsetTop;
        }
        currentPiece = checkPieceClicked();
        if (currentPiece !== null) {
            stage.clearRect(
                currentPiece.xPos,
                currentPiece.yPos,
                pieceWidth,
                pieceHeight
            );
            stage.save();
            stage.globalAlpha = 0.9;
            stage.drawImage(
                img,
                currentPiece.sx,
                currentPiece.sy,
                pieceWidth,
                pieceHeight,
                mouse.x - pieceWidth / 2,
                mouse.y - pieceHeight / 2,
                pieceWidth,
                pieceHeight
            );
            stage.restore();
            document.onpointermove = updatePuzzle;
            document.onpointerup = pieceDropped;
        }
    }

    function gameOver() {
        document.onpointerdown = null;
        document.onpointermove = null;
        document.onpointerup = null;
        initPuzzle();
    }

    function pieceDropped(e) {
        document.onpointermove = null;
        document.onpointerup = null;
        if (currentDropPiece !== null) {
            let tmp = {
                xPos: currentPiece.xPos,
                yPos: currentPiece.yPos
            };
            currentPiece.xPos = currentDropPiece.xPos;
            currentPiece.yPos = currentDropPiece.yPos;
            currentDropPiece.xPos = tmp.xPos;
            currentDropPiece.yPos = tmp.yPos;
        }
        resetPuzzleAndCheckWin();
    }

    function resetPuzzleAndCheckWin() {
        stage.clearRect(0, 0, puzzleWidth, puzzleHeight);
        let gameWin = true;
        for (piece of pieces) {
            stage.drawImage(
                img,
                piece.sx,
                piece.sy,
                pieceWidth,
                pieceHeight,
                piece.xPos,
                piece.yPos,
                pieceWidth,
                pieceHeight
            );
            stage.strokeRect(piece.xPos, piece.yPos, pieceWidth, pieceHeight);
            if (piece.xPos != piece.sx || piece.yPos != piece.sy) {
                gameWin = false;
            }
        }
        if (gameWin) {
            setTimeout(gameOver, 500);
        }
    }

    function shuffleArray(o) {
        for (
            var j, x, i = o.length;
            i;
            j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x
        );
        return o;
    }

    function updateDifficulty(e) {
        difficulty = e.target.value;
        pieceWidth = Math.floor(img.width / difficulty);
        pieceHeight = Math.floor(img.height / difficulty);
        puzzleWidth = pieceWidth * difficulty;
        puzzleHeight = pieceHeight * difficulty;
        gameOver();
    }
    document.querySelector("#difficulty").oninput = updateDifficulty;
</script>

</body>
</html>



